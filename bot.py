from aiogram import Bot, Dispatcher, types
from aiogram.enums import ParseMode
from aiogram.filters import Command
from aiogram.types import FSInputFile, InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup, KeyboardButton
from aiogram.utils.keyboard import InlineKeyboardBuilder
import aiohttp
from bs4 import BeautifulSoup
import logging
import asyncio
import os
from yt_dlp import YoutubeDL
from pathlib import Path

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

BOT_TOKEN = 'YOUR_BOT_TOKEN'
bot = Bot(token=BOT_TOKEN)
dp = Dispatcher()

user_data = {}
DONATE_URL = "https://www.donationalerts.com/r/black_h0le_d"  # –°—Å—ã–ª–∫–∞ –Ω–∞ –¥–æ–Ω–∞—Ç
RUTUBE_DOWNLOAD_SITE = "https://cobalt.tools/?url="  # –°–∞–π—Ç –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –≤–∏–¥–µ–æ —Å Rutube

def save_user_query(chat_id: int, query: str):
    if chat_id not in user_data:
        user_data[chat_id] = {
            "history": [],
            "results": [],
            "index": 0,
            "type": None,
            "favorites": [],
            "settings": {"default_platform": None},
            "is_searching": False
        }
    if user_data[chat_id]["is_searching"]:
        user_data[chat_id]["history"].append(query)
        if len(user_data[chat_id]["history"]) > 10:
            user_data[chat_id]["history"] = user_data[chat_id]["history"][-10:]

def create_start_keyboard():
    return ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text="‚ñ∂Ô∏è –ù–∞—á–∞—Ç—å")]],
        resize_keyboard=True
    )

def create_main_menu():
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="üé• –í–∏–¥–µ–æ –Ω–∞ Rutube"), KeyboardButton(text="üéµ –ú—É–∑—ã–∫–∞ –Ω–∞ Bandcamp")],
            [KeyboardButton(text="‚≠ê –ò–∑–±—Ä–∞–Ω–Ω–æ–µ"), KeyboardButton(text="‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏")],
            [KeyboardButton(text="üìú –ò—Å—Ç–æ—Ä–∏—è"), KeyboardButton(text="‚ùå –û—á–∏—Å—Ç–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é")],
            [KeyboardButton(text="‚ÑπÔ∏è –ü–æ–º–æ—â—å"), KeyboardButton(text="üí∞ –î–æ–Ω–∞—Ç")]  # –î–æ–±–∞–≤–ª–µ–Ω–∞ –∫–Ω–æ–ø–∫–∞ –¥–æ–Ω–∞—Ç–∞
        ],
        resize_keyboard=True
    )

@dp.message(Command("start"))
async def start_bot(message: types.Message):
    name = message.from_user.first_name
    username = message.from_user.username
    greeting = f"–ü—Ä–∏–≤–µ—Ç, {name}!" + (f" (@{username})" if username else "")
    await message.answer(greeting)
    await message.answer(
        "–Ø –±–æ—Ç –¥–ª—è –ø–æ–∏—Å–∫–∞ –≤–∏–¥–µ–æ –∏ –º—É–∑—ã–∫–∏. –ù–∞–∂–º–∏ ¬´‚ñ∂Ô∏è –ù–∞—á–∞—Ç—å¬ª, —á—Ç–æ–±—ã –≤—ã–±—Ä–∞—Ç—å —Ç–∏–ø –ø–æ–∏—Å–∫–∞.",
        reply_markup=create_start_keyboard()
    )

@dp.message(lambda message: message.text == "üí∞ –î–æ–Ω–∞—Ç")
async def donate_handler(message: types.Message):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ 'üí∞ –î–æ–Ω–∞—Ç'."""
    await message.answer(
        "–°–ø–∞—Å–∏–±–æ –∑–∞ –ø–æ–¥–¥–µ—Ä–∂–∫—É! –í—ã –º–æ–∂–µ—Ç–µ —Å–¥–µ–ª–∞—Ç—å –¥–æ–Ω–∞—Ç –ø–æ —Å—Å—ã–ª–∫–µ –Ω–∏–∂–µ:",
        reply_markup=InlineKeyboardMarkup(
            inline_keyboard=[
                [InlineKeyboardButton(text="‚ù§Ô∏è –ü–µ—Ä–µ–π—Ç–∏ –∫ –¥–æ–Ω–∞—Ç—É", url=DONATE_URL)]
            ]
        )
    )

@dp.message(lambda message: message.text == "‚ñ∂Ô∏è –ù–∞—á–∞—Ç—å")
async def start_search(message: types.Message):
    await message.answer("–í—ã–±–µ—Ä–∏, —á—Ç–æ —Ç—ã —Ö–æ—á–µ—à—å –∏—Å–∫–∞—Ç—å:", reply_markup=create_main_menu())

@dp.message(lambda message: message.text in ["üé• –í–∏–¥–µ–æ –Ω–∞ Rutube", "üéµ –ú—É–∑—ã–∫–∞ –Ω–∞ Bandcamp"])
async def choose_search_type(message: types.Message):
    chat_id = message.chat.id
    if chat_id not in user_data:
        user_data[chat_id] = {
            "history": [],
            "results": [],
            "index": 0,
            "type": None,
            "favorites": [],
            "settings": {"default_platform": None},
            "is_searching": True
        }
    else:
        user_data[chat_id]["is_searching"] = True
    user_data[chat_id]["type"] = "video" if message.text == "üé• –í–∏–¥–µ–æ –Ω–∞ Rutube" else "music"
    await message.answer(
        f"–û—Ç–ª–∏—á–Ω–æ! –¢–µ–ø–µ—Ä—å —è –±—É–¥—É –∏—Å–∫–∞—Ç—å {'–≤–∏–¥–µ–æ –Ω–∞ Rutube' if user_data[chat_id]['type'] == 'video' else '–º—É–∑—ã–∫—É –Ω–∞ Bandcamp'}. –í–≤–µ–¥–∏ –∑–∞–ø—Ä–æ—Å:",
        reply_markup=ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é")]], resize_keyboard=True)
    )

@dp.message()
async def process_query(message: types.Message):
    chat_id = message.chat.id
    query = message.text.strip()
    if query == "üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é":
        await return_to_menu(message)
        return
    if chat_id not in user_data or not user_data[chat_id]["type"]:
        await message.answer("–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏ —Ç–∏–ø –ø–æ–∏—Å–∫–∞.", reply_markup=create_main_menu())
        return
    if user_data[chat_id]["is_searching"]:
        save_user_query(chat_id, query)
    if user_data[chat_id]["type"] == "video":
        results = await find_videos(query)
    elif user_data[chat_id]["type"] == "music":
        results = await find_music(query)
    if not results:
        await message.answer("–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ. –ü–æ–ø—Ä–æ–±—É–π –¥—Ä—É–≥–æ–π –∑–∞–ø—Ä–æ—Å.", reply_markup=create_main_menu())
        return
    user_data[chat_id]["results"] = results
    user_data[chat_id]["index"] = 0
    await show_results(chat_id, message)

async def find_videos(query: str):
    url = f"https://rutube.ru/api/search/video/?query={query}"
    headers = {"User-Agent": "Mozilla/5.0"}
    async with aiohttp.ClientSession() as session:
        async with session.get(url, headers=headers) as response:
            if response.status == 200:
                data = await response.json()
                return [(item.get("title", "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è"), f"https://rutube.ru/video/{item.get('id')}/") for item in data.get("results", [])]
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞: {response.status}")
    return []

async def find_music(query: str):
    url = f"https://bandcamp.com/search?q={query}"
    headers = {"User-Agent": "Mozilla/5.0"}
    async with aiohttp.ClientSession() as session:
        async with session.get(url, headers=headers) as response:
            if response.status == 200:
                soup = BeautifulSoup(await response.text(), 'html.parser')
                return [(item.find('div', {'class': 'heading'}).text.strip(), item.find('a')['href']) for item in soup.find_all('li', {'class': 'searchresult'})]
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞: {response.status}")
    return []

async def show_results(chat_id: int, message: types.Message = None):
    results = user_data[chat_id]["results"]
    if not results:
        await bot.send_message(chat_id, "–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")
        return
    max_results_to_show = 10
    total_results = len(results)
    pages = [results[i:i + max_results_to_show] for i in range(0, total_results, max_results_to_show)]
    current_page = user_data[chat_id].get("current_page", 0)
    user_data[chat_id]["current_page"] = current_page
    for idx, result in enumerate(pages[current_page], start=current_page * max_results_to_show + 1):
        text = f"üîç –†–µ–∑—É–ª—å—Ç–∞—Ç {idx}/{total_results}\n"
        text += f"üìå –ù–∞–∑–≤–∞–Ω–∏–µ: {result[0]}\nüîó –°—Å—ã–ª–∫–∞: {result[1]}"
        
        # –°–æ–∑–¥–∞–µ–º –∏–Ω–ª–∞–π–Ω-–∫–ª–∞–≤–∏–∞—Ç—É—Ä—É
        keyboard = InlineKeyboardMarkup(inline_keyboard=[])
        if user_data[chat_id]["type"] == "video":  # Add download link only for videos
            download_link = f"{RUTUBE_DOWNLOAD_SITE}{result[1]}"
            keyboard.inline_keyboard.append([InlineKeyboardButton(text="‚¨áÔ∏è –°–∫–∞—á–∞—Ç—å", url=download_link)])
        elif user_data[chat_id]["type"] == "music":
            keyboard.inline_keyboard.append([InlineKeyboardButton(text="‚¨áÔ∏è –°–∫–∞—á–∞—Ç—å", callback_data=f"download_{idx - 1}")])
        
        keyboard.inline_keyboard.append([
            InlineKeyboardButton(text="‚≠ê –í –∏–∑–±—Ä–∞–Ω–Ω–æ–µ", callback_data=f"add_fav_{idx - 1}"),
            InlineKeyboardButton(text="‚ùå –ó–∞–∫–æ–Ω—á–∏—Ç—å", callback_data="stop")
        ])

        if message:
            await message.answer(text, parse_mode=ParseMode.HTML, reply_markup=keyboard)
        else:
            await bot.send_message(chat_id, text, parse_mode=ParseMode.HTML, reply_markup=keyboard)

    # –î–æ–±–∞–≤–ª—è–µ–º –ø–∞–≥–∏–Ω–∞—Ü–∏—é, –µ—Å–ª–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –±–æ–ª—å—à–µ –æ–¥–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã
    if len(pages) > 1:
        keyboard = InlineKeyboardMarkup(inline_keyboard=[])
        if current_page > 0:
            keyboard.inline_keyboard.append([InlineKeyboardButton(text="‚Üê –ü—Ä–µ–¥—ã–¥—É—â–∞—è", callback_data="prev_page")])
        if current_page < len(pages) - 1:
            keyboard.inline_keyboard.append([InlineKeyboardButton(text="–°–ª–µ–¥—É—é—â–∞—è ‚Üí", callback_data="next_page")])
        if message:
            await message.answer("–î–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ –º–µ–∂–¥—É —Å—Ç—Ä–∞–Ω–∏—Ü–∞–º–∏:", reply_markup=keyboard)
        else:
            await bot.send_message(chat_id, "–î–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ –º–µ–∂–¥—É —Å—Ç—Ä–∞–Ω–∏—Ü–∞–º–∏:", reply_markup=keyboard)

@dp.callback_query(lambda c: c.data.startswith("download_"))
async def download_file(callback: types.CallbackQuery):
    chat_id = callback.message.chat.id
    try:
        index = int(callback.data.split("_")[1])
    except (ValueError, IndexError):
        await callback.answer("–û—à–∏–±–∫–∞: –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö.")
        return

    if chat_id not in user_data or "results" not in user_data[chat_id]:
        await callback.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è.")
        return

    results = user_data[chat_id]["results"]
    if index < 0 or index >= len(results):
        await callback.answer("–í—ã–±—Ä–∞–Ω–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è.")
        return

    result = results[index]
    url = result[1]

    loading_message = await callback.message.answer("‚è≥ –ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–∞...")
    file_paths = await download_media(url, chat_id)

    if not file_paths:
        await loading_message.edit_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å —Ñ–∞–π–ª.")
        return

    try:
        for file_path in file_paths:
            file_size = os.path.getsize(file_path)
            if file_size > 50 * 1024 * 1024:
                document = FSInputFile(file_path)
                await bot.send_document(chat_id, document=document, caption="–§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –∫–∞–∫ –º–µ–¥–∏–∞, –æ—Ç–ø—Ä–∞–≤–ª—è—é –∫–∞–∫ –¥–æ–∫—É–º–µ–Ω—Ç.")
            else:
                if file_path.endswith('.mp3'):
                    audio = FSInputFile(file_path)
                    await bot.send_audio(chat_id, audio=audio, caption="–ó–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–π –∞—É–¥–∏–æ—Ñ–∞–π–ª")
                else:
                    document = FSInputFile(file_path)
                    await bot.send_document(chat_id, document=document, caption="–ó–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–π —Ñ–∞–π–ª")
            await asyncio.sleep(1)
        await loading_message.edit_text("‚úÖ –í—Å–µ —Ñ–∞–π–ª—ã —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω—ã!")
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Ñ–∞–π–ª–∞: {e}")
        await callback.message.answer(f"–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: {str(e)}")
    finally:
        for file_path in file_paths:
            if os.path.exists(file_path):
                os.remove(file_path)

    await callback.message.edit_reply_markup(reply_markup=None)

async def download_media(url: str, chat_id: int):
    try:
        with YoutubeDL({'format': 'bestaudio/best', 'outtmpl': '%(title)s.%(ext)s'}) as ydl:
            info = ydl.extract_info(url, download=True)
            directory = Path.cwd()
            downloaded_files = [str(file) for file in directory.iterdir() if file.is_file() and file.stat().st_ctime > os.path.getctime(__file__)]
            return downloaded_files
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏–∏: {e}")
        return []

@dp.callback_query(lambda c: c.data.startswith("add_fav_"))
async def add_to_favorites(callback: types.CallbackQuery):
    chat_id = callback.message.chat.id
    try:
        index = int(callback.data.split("_")[1])
    except (ValueError, IndexError):
        await callback.answer("–û—à–∏–±–∫–∞: –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö.")
        return

    if chat_id not in user_data or "results" not in user_data[chat_id]:
        await callback.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ.")
        return

    results = user_data[chat_id]["results"]
    if index < 0 or index >= len(results):
        await callback.answer("–í—ã–±—Ä–∞–Ω–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ.")
        return

    user_data[chat_id]["favorites"].append(results[index])
    await callback.answer("–î–æ–±–∞–≤–ª–µ–Ω–æ –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ!")

@dp.callback_query(lambda c: c.data == "stop")
async def stop_search(callback: types.CallbackQuery):
    chat_id = callback.message.chat.id
    user_data[chat_id]["results"] = []
    user_data[chat_id]["index"] = 0
    await callback.answer("–ü–æ–∏—Å–∫ –∑–∞–≤–µ—Ä—à—ë–Ω.")
    await callback.message.answer("–ü–æ–∏—Å–∫ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=create_main_menu())

@dp.message(lambda message: message.text == "üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é")
async def return_to_menu(message: types.Message):
    chat_id = message.chat.id
    if chat_id in user_data:
        user_data[chat_id]["is_searching"] = False
    await message.answer("–í—ã –≤–µ—Ä–Ω—É–ª–∏—Å—å –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é.", reply_markup=create_main_menu())

@dp.message(lambda message: message.text == "‚≠ê –ò–∑–±—Ä–∞–Ω–Ω–æ–µ")
async def show_favorites(message: types.Message):
    chat_id = message.chat.id
    if not user_data.get(chat_id, {}).get("favorites"):
        await message.answer("–í –∏–∑–±—Ä–∞–Ω–Ω–æ–º –ø–æ–∫–∞ –Ω–∏—á–µ–≥–æ –Ω–µ—Ç.")
        return

    builder = InlineKeyboardBuilder()
    for idx, item in enumerate(user_data[chat_id]["favorites"], 1):
        builder.add(InlineKeyboardButton(text=f"‚≠ê {idx}", callback_data=f"fav_{idx}"))
    builder.adjust(2)
    await message.answer("–í–∞—à–µ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ:", reply_markup=builder.as_markup())

@dp.callback_query(lambda c: c.data.startswith("fav_"))
async def show_favorite_item(callback: types.CallbackQuery):
    index = int(callback.data.split("_")[1]) - 1
    item = user_data[callback.message.chat.id]["favorites"][index]
    await callback.message.answer(f"‚≠ê –ò–∑–±—Ä–∞–Ω–Ω–æ–µ:\n{item[0]}\n{item[1]}")

@dp.message(lambda message: message.text == "üìú –ò—Å—Ç–æ—Ä–∏—è")
async def show_history(message: types.Message):
    chat_id = message.chat.id
    if chat_id in user_data and user_data[chat_id]["history"]:
        history = "\n".join(f"{i}. {item}" for i, item in enumerate(user_data[chat_id]["history"], 1))
        await message.answer(f"–ò—Å—Ç–æ—Ä–∏—è –∑–∞–ø—Ä–æ—Å–æ–≤:\n{history}")
    else:
        await message.answer("–ò—Å—Ç–æ—Ä–∏—è –∑–∞–ø—Ä–æ—Å–æ–≤ –ø—É—Å—Ç–∞.")

@dp.message(lambda message: message.text == "‚ùå –û—á–∏—Å—Ç–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é")
async def clear_history(message: types.Message):
    chat_id = message.chat.id
    if chat_id in user_data:
        user_data[chat_id]["history"] = []
        await message.answer("–ò—Å—Ç–æ—Ä–∏—è –∑–∞–ø—Ä–æ—Å–æ–≤ –æ—á–∏—â–µ–Ω–∞.", reply_markup=create_main_menu())
    else:
        await message.answer("–ò—Å—Ç–æ—Ä–∏—è –∑–∞–ø—Ä–æ—Å–æ–≤ —É–∂–µ –ø—É—Å—Ç–∞.", reply_markup=create_main_menu())

async def run_bot():
    try:
        logger.info("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω!")
        await dp.start_polling(bot)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞: {e}")

if __name__ == '__main__':
    asyncio.run(run_bot())
